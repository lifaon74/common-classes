!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define("common-classes",["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["common-classes"]={})}(this,(function(e){"use strict";const t=Symbol("color-private-context");function s(e,t){return Object.getOwnPropertyDescriptor(e,t)}function n(e,t,s){return Object.defineProperty(e,t,s)}function r(e){return function(e){return Object.getOwnPropertyNames(e)}(e).concat(function(e){return Object.getOwnPropertySymbols(e)}(e))}function l(e){return Object.getPrototypeOf(e)}const a=new Set(["__defineGetter__","__defineSetter__","__lookupGetter__","__lookupSetter__","__proto__"]),o=new Set(["prototype","constructor"]);function c(e){return!function(e){return o.has(e)||a.has(e)}(e)}function i(e,t){return Object.freeze(Array.from(function*(e){const t=r(e);for(let n=0,r=t.length;n<r;n++){const r=t[n];yield[r,s(e,r),e]}}(e)).filter((([e])=>c(e))).map((([e,s])=>{if("function"==typeof s.value)return{propertyKey:e,descriptor:s};throw new TypeError(`${t}: for property '${String(e)}' - only functions are accepted`)})))}const u=l(Object),h=new WeakMap;function d(){return e=>{if("function"!=typeof e)throw new TypeError("@Trait: expects a class");if(h.has(e))throw new Error(`@Trait<${e.name}>: already registered as a trait`);{const t=l(e);if(t!==u&&null!==t&&!h.has(t))throw new Error(`@Trait<${e.name}>: provided trait (class) must extends another trait or nothing`);h.set(e,Object.freeze({trait:e,ownMethods:i(e.prototype,`@Trait<${e.name}>:`),parent:h.get(t)}))}}}const g=new WeakMap;function f(){return e=>{if("function"!=typeof e)throw new TypeError("@Impl: expects a class");if(g.has(e))throw new Error(`@Impl<${e.name}>: already registered as an implementation`);{const t=l(e);if(!h.has(t))throw new Error(`@Impl<${e.name}>: the implementation is not extending a trait`);g.set(e,Object.freeze({implementation:e,ownMethods:i(e.prototype,`@Impl<${e.name}>:`),forTrait:h.get(t)}))}}}function p(e,t,s){const r=t.propertyKey;if(!s.has(r)){if(function(e,t){return t in e}(e,r)&&e[r]!==Object.prototype[r])throw new Error(`The property '${String(r)}' is already defined`);n(e,r,t.descriptor),s.add(r)}}function x(e,t){const s=new Set;!function(e,t,s){const n=t.ownMethods;for(let t=0,r=n.length;t<r;t++)p(e,n[t],s)}(e,t,s),function(e,t,s){for(;void 0!==t;){const n=t.ownMethods;for(let t=0,r=n.length;t<r;t++)p(e,n[t],s);t=t.parent}}(e,t.forTrait,s)}const m=new WeakMap;function w(e,t){!function(e,t){let s;if(m.has(e)?s=m.get(e):(s=new Set,m.set(e,s)),s.has(t))throw new Error("Implementation already applied for this target");x(e,t),s.add(t)}(e,function(e){if(g.has(e))return g.get(e);throw new Error(function(e){return`'${e.name}' is not an implementation. Did you forgot the decorator @Impl() ?`}(e))}(t))}function y(e,t,s,n){var r,l=arguments.length,a=l<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,s):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,s,n);else for(var o=e.length-1;o>=0;o--)(r=e[o])&&(a=(l<3?r(a):l>3?r(t,s,a):r(t,s))||a);return l>3&&a&&Object.defineProperty(t,s,a),a}let b=class{};b=y([d()],b);let $=class{};$=y([d()],$);let R=class{};R=y([d()],R);let v=class{};v=y([d()],v);let E=class extends v{toggle(e=!this.isActivated()){return e?this.activate():this.deactivate()}};E=y([d()],E);let G=class{};G=y([d()],G);let B=class{};B=y([d()],B);let O=class{};O=y([d()],O);let S=class{};S=y([d()],S);let A=class{};A=y([d()],A);let _=class{};_=y([d()],_);let M=class extends _{subtract(e){return this.add(e.negate())}};var j;M=y([d()],M),function(e){e[e.Less=-1]="Less",e[e.Equal=0]="Equal",e[e.Greater=1]="Greater"}(j||(j={}));let T=class{};T=y([d()],T);let I=class{};I=y([d()],I);let P=class extends I{compare(e){return 0===this.compare(e)}};P=y([d()],P);let k=class{};k=y([d()],k);let L=class extends k{notEquals(e){return!this.equals(e)}};function C(e,t){e.isDispatching()?setImmediate((()=>C(e,t))):t()}function H(e,t){return new Promise(((s,n)=>{C(e,(()=>{try{s(t())}catch(e){n(e)}}))}))}L=y([d()],L);let q=class{};q=y([d()],q);let Q=class extends q{dispatchQueued(e,t){return H(this,(()=>{this.dispatch(e,t)}))}};function D(e,t){return new Promise(((s,n)=>{e.queue((()=>{try{s(t())}catch(e){n(e)}}))}))}Q=y([d()],Q);let N=class extends q{dispatchQueued(e,t){return D(this,(()=>{this.dispatch(e,t)}))}};N=y([d()],N);let W=class{};W=y([d()],W);let z=class{};z=y([d()],z);let K=class{};K=y([d()],K);let F=class extends K{onQueued(e,t){return H(this,(()=>function(e,t,s){let n;const r=e.on(t,(e=>{void 0===n&&s(e)}));return()=>(void 0===n&&(n=H(e,r)),n)}(this,e,t)))}};F=y([d()],F);let U=class{onQueued(e,t){return D(this,(()=>function(e,t,s){let n;const r=e.on(t,(e=>{void 0===n&&s(e)}));return()=>(void 0===n&&(n=D(e,r)),n)}(this,e,t)))}};U=y([d()],U);let V=class{};V=y([d()],V);let J=class{};J=y([d()],J);let X=class extends J{onceQueued(e,t){return H(this,(()=>function(e,t,s){let n;const r=e.on(t,(e=>{void 0===n&&(l(),s(e))})),l=()=>(void 0===n&&(n=H(e,r)),n);return l}(this,e,t)))}};X=y([d()],X);let Y=class{onceQueued(e,t){return D(this,(()=>function(e,t,s){let n;const r=e.on(t,(e=>{void 0===n&&(l(),s(e))})),l=()=>(void 0===n&&(n=D(e,r)),n);return l}(this,e,t)))}};Y=y([d()],Y);let Z=class{};Z=y([d()],Z);let ee=class extends Z{once(e,t){const s=this.on(e,(e=>{s(),t(e)}));return s}};ee=y([d()],ee);let te=class{};te=y([d()],te);let se=class{};se=y([d()],se);let ne=class{};ne=y([d()],ne);let re=class{};re=y([d()],re);let le=class{};le=y([d()],le);let ae=class{};ae=y([d()],ae);const oe=Symbol("alloc");let ce=class{};ce=y([d()],ce);let ie=class{as(e){return e(this)}};ie=y([d()],ie);let ue=class{};ue=y([d()],ue);let he=class{};he=y([d()],he);let de=class{};de=y([d()],de);let ge=class extends de{getQueue(){return function(e){return new Promise((t=>{e.queue(t)}))}(this)}};ge=y([d()],ge);let fe=class{};fe=y([d()],fe);let pe=class{};pe=y([d()],pe);let xe=class extends pe{getRed(){return this[t].r}};xe=y([f()],xe);let me=class{};me=y([d()],me);let we=class extends me{getAlpha(){return this[t].a}};we=y([f()],we);let ye=class{};ye=y([d()],ye);let be=class extends ye{getBlue(){return this[t].b}};be=y([f()],be);let $e=class{};$e=y([d()],$e);let Re=class extends $e{getGreen(){return this[t].g}};Re=y([f()],Re);let ve=class{};function Ee(e,t){if("number"==typeof e){if(0<=e&&e<=1)return e;throw new RangeError(`Expected '${t}' in the range [0, 1]`)}throw new TypeError(`Expected number as '${t}'`)}ve=y([d()],ve);let Ge=class extends ve{setAlpha(e){this[t].a=Ee(e,"a")}};Ge=y([f()],Ge);let Be=class{};Be=y([d()],Be);let Oe=class extends Be{setBlue(e){this[t].b=Ee(e,"b")}};Oe=y([f()],Oe);let Se=class{};Se=y([d()],Se);let Ae=class extends Se{setGreen(e){this[t].g=Ee(e,"g")}};Ae=y([f()],Ae);let _e=class{};_e=y([d()],_e);let Me=class extends _e{setRed(e){this[t].r=Ee(e,"r")}};Me=y([f()],Me);let je=class extends I{};je=y([d()],je);let Te=class extends je{equals(e){return this.getRed()===e.getRed()&&this.getGreen()===e.getGreen()&&this.getBlue()===e.getBlue()&&this.getAlpha()===e.getAlpha()}};Te=y([d()],Te);let Ie=class extends Te{};Ie=y([f()],Ie);let Pe=class{};Pe=y([d()],Pe);let ke=class extends Pe{toRGB(e=!1){return`rgb${e?"a":""}(${Math.round(255*this.getRed())}, ${Math.round(255*this.getGreen())}, ${Math.round(255*this.getBlue())}${e?", "+this.getAlpha():""})`}};ke=y([d()],ke);let Le=class extends ke{};Le=y([f()],Le);let Ce=class{toRGBA(){return this.toRGB(!0)}};Ce=y([d()],Ce);let He=class extends Ce{};He=y([f()],He);let qe=class{};qe=y([d()],qe);let Qe=class extends qe{toHSL(e=!1){const t=this.toHSLAObject();return`hsl${e?"a":""}(${360*t.h}, ${100*t.s}%, ${100*t.l}%${e?", "+t.a:""})`}};Qe=y([d()],Qe);let De=class extends Qe{};De=y([f()],De);let Ne=class{toHSLA(){return this.toHSL(!0)}};Ne=y([d()],Ne);let We=class extends Ne{};We=y([f()],We);let ze=class{};ze=y([d()],ze);let Ke=class extends ze{toHSLAObject(){const e=this.getRed(),t=this.getGreen(),s=this.getBlue(),n=this.getAlpha(),r=Math.max(e,t,s),l=Math.min(e,t,s),a={h:0,s:0,l:(r+l)/2,a:n};if(r===l)a.h=0,a.s=0;else{const n=r-l;switch(a.s=a.l>.5?n/(2-r-l):n/(r+l),r){case e:a.h=(t-s)/n+(t<s?6:0);break;case t:a.h=(s-e)/n+2;break;case s:a.h=(e-t)/n+4}a.h/=6}return a}};Ke=y([d()],Ke);let Fe=class extends Ke{};Fe=y([f()],Fe);let Ue=class extends ue{};Ue=y([d()],Ue);let Ve=class extends Ue{toString(){return this.toRGB(!0)}};Ve=y([d()],Ve);let Je=class extends Ve{};Je=y([f()],Je);let Xe=class{};function Ye(e,t=2){return e.toString(16).padStart(t,"0")}Xe=y([d()],Xe);let Ze=class extends Xe{toHex(e=!1){return`#${Ye(Math.round(255*this.getRed()),2)}${Ye(Math.round(255*this.getGreen()),2)}${Ye(Math.round(255*this.getBlue()),2)}${e?Ye(Math.round(255*this.getAlpha()),2):""}`}};Ze=y([d()],Ze);let et=class extends Ze{};et=y([f()],et);let tt=class extends ce{};tt=y([d()],tt);let st=class extends tt{[oe](e,t,s,n){return new Pt(e,t,s,n)}};st=y([f()],st);let nt=class{};nt=y([d()],nt);let rt=class extends nt{mix(e,t){if(0<=t&&t<=1){const s=1-t;return this[oe](this.getRed()*s+e.getRed()*t,this.getGreen()*s+e.getGreen()*t,this.getBlue()*s+e.getBlue()*t,this.getAlpha()*s+e.getAlpha()*t)}throw new RangeError("Expected 'proportion' in the range [0, 1]")}};rt=y([d()],rt);let lt=class extends rt{};lt=y([f()],lt);let at=class{};function ot(e,t,s){e=e.trim();let n=parseFloat(e);if(Number.isNaN(n))throw new Error("Invalid number: "+e);if(e.endsWith("%")&&(n*=s/100),t<=n&&n<=s)return n;throw new RangeError(`Invalid range [${t}-${s}] for number ${n}`)}at=y([d()],at);const ct="\\s*(\\d+(?:\\.\\d+)?%?)\\s*",it=new RegExp(`rgb(a)?\\(${ct},${ct},${ct}(?:,${ct})?\\)`);let ut=class extends at{parseRGB(e){it.lastIndex=0;const t=it.exec(e);if(null!==t&&typeof t[1]==typeof t[5])return this[oe](ot(t[2],0,255)/255,ot(t[3],0,255)/255,ot(t[4],0,255)/255,void 0===t[5]?1:ot(t[5],0,1));throw new Error("Invalid rgb(a) color: "+e)}};ut=y([d()],ut);let ht=class extends ut{};ht=y([f()],ht);let dt=class{};dt=y([d()],dt);let gt=class extends dt{parse(e){const t=document.createElement("div");if(t.style.setProperty("color",e),t.style.getPropertyValue("color")){document.body.appendChild(t);const e=window.getComputedStyle(t).color;return document.body.removeChild(t),this.parseRGB(e)}return null}};gt=y([d()],gt);let ft=class extends gt{};ft=y([f()],ft);let pt=class{};pt=y([d()],pt);let xt=class extends pt{grayscale(e="luminosity"){let t;switch(e){case"average":t=(this.getRed()+this.getGreen()+this.getBlue())/3;break;case"lightness":t=(Math.max(this.getRed(),this.getGreen(),this.getBlue())+Math.min(this.getRed(),this.getGreen(),this.getBlue()))/2;break;case"luminosity":t=.21*this.getRed()+.72*this.getGreen()+.07*this.getBlue();break;default:throw new TypeError(`Unexpected grayscale's mode: '${e}'`)}return this[oe](t,t,t,this.getAlpha())}};xt=y([d()],xt);let mt=class extends xt{};mt=y([f()],mt);let wt=class{};function yt(e,t,s){return s<0&&(s+=1),s>1&&(s-=1),s<1/6?e+6*(t-e)*s:s<.5?t:s<2/3?e+(t-e)*(2/3-s)*6:e}wt=y([d()],wt);let bt=class extends wt{fromHSLAObject(e){let t,s,n;if(0===e.s)t=s=n=e.l;else{const r=e.l<.5?e.l*(1+e.s):e.l+e.s-e.l*e.s,l=2*e.l-r;t=yt(l,r,e.h+1/3),s=yt(l,r,e.h),n=yt(l,r,e.h-1/3)}return this[oe](t,s,n,e.a?e.a:1)}};bt=y([d()],bt);let $t=class extends bt{};$t=y([f()],$t);let Rt=class{};Rt=y([d()],Rt);let vt=class extends Rt{invert(e=1){if(0<=e&&e<=1)return this[oe](e*(1-this.getRed())+(1-e)*this.getRed(),e*(1-this.getGreen())+(1-e)*this.getGreen(),e*(1-this.getBlue())+(1-e)*this.getBlue(),this.getAlpha());throw new RangeError("Expected 'amount' in the range [0, 1]")}};vt=y([d()],vt);let Et=class extends vt{};Et=y([f()],Et);let Gt=class{};Gt=y([d()],Gt);let Bt=class extends Gt{lighten(e){const t=this.toHSLAObject();return t.l=Math.max(0,Math.min(1,t.l+e)),this.constructor.fromHSLAObject(t)}};Bt=y([d()],Bt);let Ot=class extends Bt{};Ot=y([f()],Ot);let St=class{};St=y([d()],St);let At=class extends St{darken(e){return this.lighten(-e)}};At=y([d()],At);let _t=class extends At{};function Mt(e,s,r,l,a){!function(e,t,s){n(t,e,{configurable:!1,enumerable:!1,writable:!1,value:s})}(t,e,{r:Ee(s,"r"),g:Ee(r,"g"),b:Ee(l,"b"),a:Ee(a,"a")})}_t=y([f()],_t);const jt=[st,xe,Me,Re,Ae,be,Oe,we,Ge,Ie,lt,mt,Et,Ot,_t,Le,He,De,We,Fe,et,Je],Tt=[st,ht,ft,$t],It=function(e,t=[],s){const n=void 0===s?class{}:class extends s{};for(let t=0,s=e.length;t<s;t++)w(n.prototype,e[t]);for(let e=0,s=t.length;e<s;e++)w(n,t[e]);return n}(jt,Tt);class Pt extends It{constructor(e,t,s,n){super(),Mt(this,e,t,s,n)}get r(){return this.getRed()}set r(e){this.setRed(e)}get g(){return this.getGreen()}set g(e){this.setGreen(e)}get b(){return this.getBlue()}set b(e){this.setBlue(e)}get a(){return this.getAlpha()}set a(e){this.setAlpha(e)}}e.Color=Pt,e.ColorConstructorImplementations=Tt,e.ColorImplementations=jt,e.ConstructColor=Mt,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=common-classes.esnext.umd.min.js.map