import { IEmitFunction, IUnsubscribeFunction } from '../../types';



export type TNodeState = 'connected' | 'disconnected' | 'destroyed';

type INodeStateToEmitFunctionsMap = Map<string, IEmitFunction<void>[]>;

const DOM_STATE_OBSERVERS = new WeakMap<Node, INodeStateToEmitFunctionsMap>();
const NODE_STATE = new WeakMap<Node, TNodeState>();

export function onNodeStateChange(
  node: Node,
  state: TNodeState,
  callback: IEmitFunction<void>
): IUnsubscribeFunction {
  let map: INodeStateToEmitFunctionsMap;
  if (DOM_STATE_OBSERVERS.has(node)) {
    map = DOM_STATE_OBSERVERS.get(node) as INodeStateToEmitFunctionsMap;
  } else {
    map = new Map<string, IEmitFunction<void>[]>();
    DOM_STATE_OBSERVERS.set(node, map);
  }

  let callbacks: IEmitFunction<void>[];
  if (map.has(state)) {
    callbacks = map.get(state) as IEmitFunction<void>[];
  } else {
    callbacks = [];
    map.set(state, callbacks);
  }

  if (callbacks.includes(callback)) {
    throw new Error(`Already observing this Node`);
  } else {
    callbacks.push(callback);
  }

  let running: boolean = true;

  return () => {
    if (running) {
      running = false;
      callbacks.splice(callbacks.indexOf(callback), 1);
    }
  };
}


export function computeNodeState(
  node: Node,
): TNodeState {
  return node.isConnected
    ? 'connected'
    : 'disconnected';
}

export function getNodeState(
  node: Node,
): TNodeState {
  if (NODE_STATE.has(node)) {
    return NODE_STATE.get(node) as TNodeState;
  } else {
    return computeNodeState(node);
  }
}

export function setNodeState(
  node: Node,
  state: TNodeState,
): void {
  if (state !== getNodeState(node)) {
    NODE_STATE.set(node, state);
    let callbacks: IEmitFunction<void>[];
    if (DOM_STATE_OBSERVERS.has(node)) {
      const map: INodeStateToEmitFunctionsMap = DOM_STATE_OBSERVERS.get(node) as INodeStateToEmitFunctionsMap;
      if (map.has(state)) {
        const callbacks: IEmitFunction<void>[] = (map.get(state) as IEmitFunction<void>[]).slice();
        for (let i = 0, l = callbacks.length; i < l; i++) {
          callbacks[i]();
        }
      }
    }
  }
}


export function setNodeStateIncludingChildren(
  node: Node,
  state: TNodeState,
): void {
  if (state !== getNodeState(node)) {
    setNodeState(node, state);
    // TODO
  }
}

export function destroyNode(
  node: Node,
): void {
  if (getNodeState(node) === 'disconnected') {
    if (node.parentNode !== null) {
      node.parentNode.removeChild(node);
    }
    setNodeStateIncludingChildren(node, 'destroyed');
  } else {
    throw new Error(`Node is '${ getNodeState(node) }'`);
  }
}

export function attachNode(
  node: Node,
  parentNode: Node,
  referenceNope: Node | null,
): void {
  if (getNodeState(node) === 'disconnected') {
    parentNode.insertBefore(node, referenceNope);
    setNodeStateIncludingChildren(node, 'connected');
  } else {
    throw new Error(`Node is '${ getNodeState(node) }'`);
  }
}

export function detachNode(
  node: Node,
): void {
  if (getNodeState(node) === 'connected') {
    if (node.parentNode !== null) {
      node.parentNode.removeChild(node);
    }
    setNodeStateIncludingChildren(node, 'disconnected');
  } else {
    throw new Error(`Node is '${ getNodeState(node) }'`);
  }
}

export function clearOnDestroyed<GNode extends Node>(
  node: GNode,
  clear: () => void,
): GNode {
  const unsubscribeOnDestroyed: IUnsubscribeFunction = onNodeStateChange(node, 'destroyed', () => {
    clear();
    unsubscribeOnDestroyed();
  });
  return node;
}


